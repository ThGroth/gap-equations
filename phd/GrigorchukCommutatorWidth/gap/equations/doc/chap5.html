<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (Equations) - Chapter 5: FR-Equations</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap5"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X7BA9260C7CF0AAE4" name="X7BA9260C7CF0AAE4"></a></p>
<div class="ChapSects"><a href="chap5.html#X7BA9260C7CF0AAE4">5 <span class="Heading">FR-Equations</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap5.html#X84C6E3E57E19EE72">5.1 <span class="Heading">Decomposable equations</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X8431319680D47763">5.1-1 DecompositionEquationGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X7FA2A56D79F97366">5.1-2 DecompositionEquation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X7EA966847C9791A0">5.1-3 EquationComponent</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X83F46D707CDA0EEE">5.1-4 DecomposedEquationDisjointForm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap5.html#X7F70CE8C780DE3C2">5.1-5 LiftSolution</a></span>
</div></div>
</div>

<h3>5 <span class="Heading">FR-Equations</span></h3>

<p><a id="X84C6E3E57E19EE72" name="X84C6E3E57E19EE72"></a></p>

<h4>5.1 <span class="Heading">Decomposable equations</span></h4>

<p>For self-similar groups one strategy to solve equations is to consider the inherit equations by passing to states. To use this methods the package FR (<a href="chapBib.html#biBFR2.3.6">[Bar16]</a>) from Laurent Bartholdi is needed.</p>

<p>Let <span class="SimpleMath">G</span> be a group which lies in the filter <var class="Arg">IsFRGroup</var> and which admitts an embedding <span class="SimpleMath">ψ: G -&gt; tilde G≀ S_n</span> where <span class="SimpleMath">tilde G</span> is the group generated by the states of the group <span class="SimpleMath">G</span>. Note that if <span class="SimpleMath">G</span> is a <em>self-similar</em> group then <span class="SimpleMath">G≃ tilde G</span>. Further let <span class="SimpleMath">F_X</span> be the free group on the generating set <span class="SimpleMath">X</span>. Given an equation group <span class="SimpleMath">G*F_X</span> we will the fix <span class="SimpleMath">n</span> natural embeddings <span class="SimpleMath">φ_i: F-&gt; F_X^n</span> and call the group <span class="SimpleMath">(tilde G*F_X^n)≀ S_n )</span> the <em>decomposition equation group</em> of <span class="SimpleMath">G*F_X</span>. The decomposition of an equation <span class="SimpleMath">e</span> with variables <span class="SimpleMath">x_1,... ,x_k</span> with respect to a choice of activities <span class="SimpleMath">σ(x_i)∈ S_n</span> for each variable <span class="SimpleMath">x_i</span> is the image of <span class="SimpleMath">e</span> under the homomorphism</p>

<div class="pcenter"><table class="GAPDocTablenoborder">
<tr>
<td class="tdright"><span class="SimpleMath">Φ_σ: G*F_X</span></td>
<td class="tdleft"><span class="SimpleMath">-&gt; (tilde G*(F_X^n)≀ S_n</span></td>
</tr>
<tr>
<td class="tdright"><span class="SimpleMath">x_i</span></td>
<td class="tdleft"><span class="SimpleMath">↦φ_i(x_i)⋅σ(x_i)</span></td>
</tr>
<tr>
<td class="tdright"><span class="SimpleMath">g</span></td>
<td class="tdleft"><span class="SimpleMath">↦ψ_i(x_i)</span></td>
</tr>
</table><br /><p>&nbsp;</p><br />
</div>

<p><a id="X8431319680D47763" name="X8431319680D47763"></a></p>

<h5>5.1-1 DecompositionEquationGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecompositionEquationGroup</code>( <var class="Arg">G</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A new <var class="Arg">EquationGroup</var>.</p>

<p>This method needs <var class="Arg">G</var> to be an equation group where the group of constants is an fr-group. For <var class="Arg">G</var> a group with free constant group see <code class="func">DecompositionEquationGroup</code>. If <span class="SimpleMath">F</span> is the free group on the generating set <span class="SimpleMath">X</span> then the free group on the gerating set <span class="SimpleMath">X^n</span> is isomorphic to <span class="SimpleMath">F^*n</span> the <span class="SimpleMath">n</span>-fold free product of <span class="SimpleMath">F</span> .</p>

<p>This method returns the <var class="Arg">EquationGroup</var> <span class="SimpleMath">G*F^*n</span>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecompositionEquationGroup</code>( <var class="Arg">G</var>, <var class="Arg">deg</var>, <var class="Arg">acts</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A new <var class="Arg">EquationGroup</var>.</p>

<p>This method needs <var class="Arg">G</var> to be an equation group where the group of constants is a free group on <span class="SimpleMath">n&lt;∞</span> generators. The integer <var class="Arg">deg</var> is the number of states each element will have. The list <var class="Arg">acts</var> should be of length <span class="SimpleMath">n</span> and all elements should be permutation of <var class="Arg">deg</var> elements. These will represent the activity of the generators of the free group.</p>

<p><a id="X7FA2A56D79F97366" name="X7FA2A56D79F97366"></a></p>

<h5>5.1-2 DecompositionEquation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecompositionEquation</code>( <var class="Arg">G</var>, <var class="Arg">E</var>, <var class="Arg">sigma</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A new equation in <var class="Arg">G</var> which is the decomposed of the equation <var class="Arg">E</var>.</p>

<p>The group <var class="Arg">G</var> needs to be a <var class="Arg">DecompositionEqationGroup(H)</var>, the equation <var class="Arg">E</var> needs to be a member of the EquationGroup <span class="SimpleMath">H=K*F</span>.</p>

<p>The argument <var class="Arg">sigma</var> needs to be a group homomorphism <span class="SimpleMath">σ: F-&gt; S_n</span>. Alternatively it can be a list of elements of <span class="SimpleMath">S_n</span> it is then regarded as the group homomorphism that maps the <span class="SimpleMath">i</span>-th variable of <var class="Arg">eq</var> to the <span class="SimpleMath">i</span>-th element of the list.</p>

<p>The representation of the returned equation stores a list of words such that the <span class="SimpleMath">i</span>-th word represents an element in <span class="SimpleMath">G*ϕ_i(F)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeGroup(1);; SetName(F,"F");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := EquationGroup(GrigorchukGroup,F);</span>
GrigorchukGroup*F
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DG := DecompositionEquationGroup(G);</span>
GrigorchukGroup*F*F
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> sigma := GroupHomomorphismByImages(F,SymmetricGroup(2),[(1,2)]);</span>
[ f1 ] -&gt; [ (1,2) ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> e := Equation(G,[F.1^2,GrigorchukGroup.2]);</span>
Equation in [ f1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> de := DecompositionEquation(DG,e,sigma);</span>
DecomposedEquation in [ f11, f12 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Print(de);</span>
Equation([ FreeProductElm([ f11*f12,a ]), FreeProductElm([ f12*f11,c ]) ])
</pre></div>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeGroup("x1","x2");; SetName(F,"F");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := FreeGroup("g");; SetName(G,"G");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">eG := EquationGroup(G,F);</span>
G*F
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DeG := DecompositionEquationGroup(eG,2,[(1,2)]);</span>
G*G*F*F
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> e := Equation(eG,[Comm(F.1,F.2),G.1^2]);</span>
Equation in [ x1, x2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> Print(DecompositionEquation(DeG,e,[(),()]));</span>
Equation([ FreeProductElm([ x11^-1*x21^-1*x11*x21, g1*g2 ]), 
 FreeProductElm([ x12^-1*x22^-1*x12*x22, g2*g1 ]) ])
</pre></div>

<p><a id="X7EA966847C9791A0" name="X7EA966847C9791A0"></a></p>

<h5>5.1-3 EquationComponent</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EquationComponent</code>( <var class="Arg">E</var>, <var class="Arg">i</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The <var class="Arg">i</var>-th component of the decomposed equation <var class="Arg">E</var>.</p>

<p>Denote by <span class="SimpleMath">p_i</span> the natural projection <span class="SimpleMath">(G*F_X^n)^n⋊ S_n-&gt; G*F_X^n</span> to the <span class="SimpleMath">i</span>-th factor of the product. Given a decomposed Equation <var class="Arg">E</var> and an integer <span class="SimpleMath">0&lt;</span><var class="Arg">i</var><span class="SimpleMath">≤ n</span> this method returns <span class="SimpleMath">p_i(E)</span>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EquationComponents</code>( <var class="Arg">E</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The list of all components of the decomposed equation <var class="Arg">E</var>.</p>

<p>Denote by <span class="SimpleMath">p_i</span> the natural projection <span class="SimpleMath">p_i:(G*F_X^n)^n⋊ S_n-&gt; G*F_X^n</span> to the <span class="SimpleMath">i</span>-th factor of the product. Given a decomposed Equation <var class="Arg">E</var> this method returns the list <span class="SimpleMath">[p_1(E),p_2(E),...,p_n(E)]</span>.</p>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EquationActivity</code>( <var class="Arg">E</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The activity of the decomposed equation <var class="Arg">E</var>.</p>

<p>Denote by <span class="SimpleMath">act</span> the natural projection <span class="SimpleMath">(G*F_X^n)≀ S_n-&gt; S_n</span>. Given a decomposed Equation <var class="Arg">E</var> this method returns <span class="SimpleMath">act(E)</span>.</p>

<p><a id="X83F46D707CDA0EEE" name="X83F46D707CDA0EEE"></a></p>

<h5>5.1-4 DecomposedEquationDisjointForm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DecomposedEquationDisjointForm</code>( <var class="Arg">E</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A record with components <var class="Arg">eq</var> and <var class="Arg">hom</var>.</p>

<p>If <var class="Arg">E</var> is a decomposed equation there may be an overlap of the set of variables of some components. If <var class="Arg">E</var> is a quadratic equation there is an equation homomorphism <span class="SimpleMath">φ</span> that maps each component to a new quadratic equation. Hence all maped components have pairwise disjoint sets of variables. This method computes such an homomorphism <span class="SimpleMath">φ</span> such that the solvability of the system of components remains unchanged. If <span class="SimpleMath">s</span> is a solution for the new system of components, then <span class="SimpleMath">s∘φ</span> is a solution for the old system.</p>

<p>The method returns a record with two components. <var class="Arg">hom</var> is the homomorphism <span class="SimpleMath">φ</span> and <var class="Arg">eq</var> the new decomposed equation.</p>

<p><a id="X7F70CE8C780DE3C2" name="X7F70CE8C780DE3C2"></a></p>

<h5>5.1-5 LiftSolution</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftSolution</code>( <var class="Arg">DE</var>, <var class="Arg">E</var>, <var class="Arg">sigma</var>, <var class="Arg">sol</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: An evaluation for E <var class="Arg">eq</var>.</p>

<p>Given an equation <var class="Arg">E</var> and a solution <var class="Arg">sol</var> for its decomposed equation <var class="Arg">DE</var> under the decomposition with activity <var class="Arg">sigma</var> this method computes a solution for the equation <var class="Arg">E</var>.</p>

<p>Note that the solution not neccecarily maps to the group of constants of <var class="Arg">E</var> but can map to the group where all elements of the group of constants can appear as states. If the group of constants is layered, this two groups will coincide.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := FreeGroup(2);; SetName(F,"F");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Gr := GrigorchukGroup;; a:=Gr.1;; d:=Gr.4;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">G := EquationGroup(Gr,F);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DG := DecompositionEquationGroup(G);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> sigma := GroupHomomorphismByImages(F,SymmetricGroup(2),[(1,2),()]);</span>
[ f1, f2 ] -&gt; [ (1,2), () ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> e := Equation(G,[Comm(F.1,F.2),Comm(d,a)]);</span>
Equation in [ f1, f2 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"> de := DecompositionEquation(DG,e,sigma);</span>
DecomposedEquation in [ f11, f21, f12, f22 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dedj := DecomposedEquationDisjointForm(de);</span>
rec( eq := DecomposedEquation in [ f11, f12, f22 ], 
  hom := [ f21 ]"-&gt;"[ FreeProductElm of length 3 ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EquationComponents(dedj.eq);</span>
[ Equation in [ f11, f12, f22 ], Equation in [  ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">s := EquationEvaluation(DG,EquationVariables(dedj.eq),[One(Gr),One(Gr),Gr.2]);</span>
MappingByFunction( GrigorchukGroup*F*F, GrigorchukGroup, function( q ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSolution(s,EquationComponent(dedj.eq,1));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ns := dedj.hom*s;; IsEvaluation(ns);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(EquationComponents(de),F-&gt;IsSolution(ns,F));</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ls := LiftSolution(de,e,sigma,ns);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsSolution(ls,e);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ForAll(EquationVariables(e),x-&gt;Equation(G,[x])^ls in Gr);</span>
true //only good luck
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap4.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chapBib.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
